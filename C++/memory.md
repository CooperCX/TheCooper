# C++ 内存管理

### 1. C++的内存分区，有5个分区：栈、堆(自由存储区)、全局\静态存储区、常量存储区、代码区
* 栈：函数执行时，局部变量的存储单元在栈上分配，函数结束时这些存储单元自动释放掉。栈的效率很高但是空间不大。
* 堆：由操作系统维护的一块内存，用于程序内存的动态分配。C语言中使用malloc/free来分配和释放内存。
* 自由存储区：凡是通过new操作符分配的内存，都属于自由存储区。C++中使用new/delete来分配和释放内存。
    * 堆和自由存储区
        * 堆是由操作系统维护的一块内存，自由存储区是C++中基于new/delete来动态分配和释放内存的抽象概念。
        * 堆和自由存储的区分方式：是malloc/free还是new/delete。
        * 自由存储区和堆并不等价，取决于new操作符的具体实现。通常来说，C++编译器的默认new/delete使用了malloc/free来实现。
* 全局\静态存储区：内存在编译期间分配好，程序运行整个期间都存在。存储全局变量和静态变量，没有初始化的变量会自动初始化。
* 常量存储区：存储的是常量，不可以修改。在C++中const修饰的变量存储在此。
* 代码区：存储的是函数体的二进制代码。

### 2. 内存池和实现
* 内存池：内存池是一种内存分配方式。先申请分配一大块内存。当程序申请内存时从中进行分配，如果不够才向操作系统申请新的内存块。
* 优点：
    * 避免频繁申请内存造成过多的内存碎片，影响性能。
    * 减少系统调用的开销。申请内存的动作由操作系统进行，分三层：应用程序、标准库、系统调用。内存池的内存分配是在应用层操作，程序申请内存时不再需要通过标准库和操作系统。
* 实现：

### 3. C++中类的成员变量和成员函数的内存分布情况
* 成员变量：类对象的内存地址，对应类中某一个成员变量的内存地址。对象的内存大小和对象的成员变量的内存大小一致，成员函数不占内存空间。原因是因为函数存储在代码区，不论全局函数还是成员函数。
* 静态成员函数和成员函数的唯一区别是没有this指针，因此不能访问非静态的数据成员。同样的，静态成员函数和成员函数都是函数，都存放在代码区，而不是静态存储区。

### 4. this指针
* this指针是类的指针，指向对象的首地址。
* this指针只能在成员函数中使用，全局函数和静态函数无法使用。当类的非静态成员函数访问非静态成员变量时，编译器自动将当前对象的地址作为隐含参数传递给函数，成员函数传入的第一个参数为当前对象的地址，T* const this。
* this指针只有在成员函数中才有定义，存储位置由编译器决定。
* this指针在成员函数开始前构造，在函数结束后清除。
* 成员函数中调用delete this：在成员函数中调用delete this，会释放对象的内存空间。后续如果不涉及对象，则正常，如涉及对象操作，会导致不可预期的问题。
    * 为什么是不可预期的问题，而不是错误？
        * 因为delete之后释放了内存空间，但是该内存空间并不会立马被系统回收，依然可以使用。
* 在类的析构函数中调用delete this：会导致堆栈溢出。因为delete会去调用类的析构函数，造成无限递归。
* this指针调用成员函数：this指针首先入栈，然后参数从右向左入栈，最后函数返回地址入栈。

### 5. 内存泄漏
* 是由于失误导致程序没有释放掉不再使用的内存，程序结束后失去了对该内存的控制。
* 后果：导致性能下降，内存使用耗尽，程序崩溃。
* 避免方法：使用智能指针，或者严格释放内存。
* 检查定位：内存检测工具，有valgrind、 sanitizer等。

### 6. 空类的大小
* 空类的大小不为0，因为C++要求不同的对象要有不用的地址，编译器自动分配1个字节。
* 空类作为基类时大小被优化为0，子类大小就是子类本身的大小。——空白基类最优化
* 带有虚函数的空类大小不为1，因为存在一个vptr指向虚函数表。
* 静态成员存储在静态存储区，不占用类的大小。
* 普通成员函数存储在代码区，不占用类的大小。

### 7. 类对象的大小
* 非静态成员变量的大小。
* 虚函数指针vptr的大小。
* 内存对齐时分配空间的大小。
* 派生类中基类部分的数据成员的大小。