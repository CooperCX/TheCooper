# 为面试准备的C++知识页面——所谓八股

## 0，NULL，nullptr
* 在C中，NULL被定义为空指针，#define NULL  ((void*)0)
* 在C++中，NULL被定义为0，#define NULL 0，nullptr被定义为空指针

## void*指针类型
* void* 是一个指针，指向一块没有数据类型的内存
* 可以指向任何类型的地址，必须强制转换才能正常取值

## 位运算bitwise
* bitset: 一个长度为N的二进制序列，可以和string和integer相互转换
* bitset<8> bitset1(12);  // 将12保存为8位二进制的序列
* bitset<8> bitset2("10101"); // 将字符串"10101"保存为8位二进制的序列

## RAII
* 资源获取即初始化，通过局部对象的生存期控制资源的生命周期。
* 在构造函数中初始化。局部对象在函数栈中声明后，会自动调用构造函数进行初始化。函数栈结束后，局部变量自动析构销毁，无需人工。常用于锁、智能指针、计时器等。

## 内存对齐
* 内存对齐是按照成员声明顺序依次安排内存的。
* 内存对齐的规则：（1）第一个成员相对首地址的偏移量为0，后面每一个成员相对首地址的偏移量为成员大小的整数倍；（2）最后整个结构体的大小为最大数据成员大小的整数倍。
* 内存对齐的好处：可以提高代码在不同平台的可移植性和内存访问性能。

## 静态联编和动态联编
* 什么是联编：通过函数调用找到特定的函数代码块执行。通俗来说就是根据函数名（和参数列表）执行对应的函数代码块
* 静态联编：在编译期间进行的联编。优点是效率更高。编译器对非虚函数使用静态联编。
* 动态联编：编译期无法确定要执行的函数，在程序运行时选择正确的函数。编译器对虚函数使用动态联编。


## 向上强制转换和向下强制转换
* 向上强制转换：将派生类引用或指针转换为基类引用或指针，不需要显式类型转换。
```
因此，指向基类的指针或引用可以引用派生类的对象。
DerivedClass derived;
BaseClass* base_ptr = &derived;
BaseClass& base_ref = derived;
因此，在函数形参为基类的指针或引用时，实参可以为基类对象、派生类对象
```

* 向下强制转换：将基类引用或指针转换为派生类引用或指针，需要显式类型转换。

## 虚函数的工作原理
* 虚函数：是实现C++三大特性之一（多态性）的方法。
* 虚函数表（V-table）：一片连续的内存，实际上是一个函数地址的数组。
* 如何实现：（1）在声明一个包含虚函数的类对象时，该对象中加了一个隐式成员，该成员为虚表指针，指向虚函数表。（2）调用虚函数时，程序将访问虚表指针，找到对应的虚函数表，然后根据使用的是第几个虚函数，调用虚函数表中对应顺序的函数。

## 虚函数的注意事项
* 构造函数不能是虚函数。
* 析构函数应为虚函数，除非不会作为基类。
* 友元函数不能是虚函数。因为友元函数不是类的成员，只有成员函数才能是虚函数。
* 没有重新定义：使用基类版本或者派生链中最新版本。
* 重新定义将隐藏：在派生类中重新定义虚函数，将隐藏基类中所有同名函数。
    * 返回类型协变：如果重新定义继承来的方法，应保持函数原型完全相同。但是如果返回类型是基类的引用或指针，则可以修改为派生类的引用或指针，允许返回类型根据类类型的变化而变化。
    * 如果基类中声明的虚函数被重载了，则应在派生类中重新定义所有重载的版本，否则会将其他版本隐藏。  

## 左值和右值
* 左值：表达式结束后依然存在的持久对象，可以取地址，具名的变量或对象。
    * 前置自增自减表达式（--a, ++b）
    * 字符串字面值（"abc"）
    * 返回值为左值引用的函数调用
    * 有赋值运算符组成的表达式（a = b, b += 1）
* 右值：表达式结束后不再存在的临时对象，不可取地址，没有名字。
    * 除了字符串字面值的其他字面值（1, 'a', ture）
    * 后置自增自减表达式（a--, b++）
    * 返回值为非引用的函数调用或操作符重载
    * 算术、逻辑、比较、取地址、lambda表达式
* 将亡值：可以被移动的具名临时值。
    * 返回右值引用T&&的函数返回值
    * std::move()的返回值
    * 转换为T&&的类型转换函数的返回值

## std::move
* 作用：移除左值属性，将一个左值变成一个右值引用（将亡值），实现移动语义
* 移动语义：将对象的状态或所有权从一个对象转移到另一个对象，没有拷贝。

## 右值引用
* 左值引用：传统的C++引用，给左值取别名。左值引用不能绑定右值。
* 右值引用(C++11): 给右值取别名。右值引用不能绑定左值。右值引用是左值。
```
int a = 10;
int &l = a;   // a是左值
int &&r = 10; // 10是右值
```

## 引用折叠
* 规则：
    * T& & -> T&
    * T&& & -> T&
    * T& && -> T&
    * T&& && -> T&&

## 模版推导
* 按值传递的模版推导：本质是对实参进行拷贝，得到实参的一个副本。因此，实参的常量性和引用性被忽略。
```
template<typename T>
returnType Function(T param) {
    Function2(param);
}
```
* 按引用传递的模版推导：忽略实参的引用性
```
template<typename T>
returnType Function(T& param) {
    Function2(param);
}
```
* 万能引用

## 万能引用
* 万能引用：函数既能接受左值类型的参数，也能接受右值类型的参数。
```
template<typename T>
returnType Function(T&& param) {
    Function2(param); // 函数内部对形参的直接使用，都是按照左值进行的。因此param是个左值类型
}
T是左值类型，T&&就是左值类型；T是右值类型，T&&就是右值类型
```

## std::forward
* 实现完美转发：std::forward会将输入的参数“原封不动”地传递到下一个函数中去。左值还是左值，右值还是右值。
* 步骤：（1）在模版中使用&&接受参数；（2）使用std::forward将参数转发给被调用的函数。
```
template<typename T>
returnType Function1(T&& param) {      // 万能引用：param既可以是左值类型，也可以是右值类型
    Function2(std::forward<T>(param)); // 完美转发：std::forward将param“原封不动“转发给Function2
}
```

## placement new
* 常规new一个对象，会先分配一个对应的内存空间，然后调用对象的构造函数构造一个对象。
* placement new：在new后面提供一个参数，作为new的地址，new会在给定的内存地址处构造对象。
```
int i = new int(10); // 常规new对象

new (&i) int(5); // placement new
```

## operator new/delete
* (T*)::operator new(size): 开辟一个大小为size的内存空间，地址的初始类型为void*，需强制转换为T*才可使用
* ::operator delete(ptr, size): 释放一个以ptr为首地址大小为size的内存空间
* 我的理解：所以new就是operator new + placement new?
```
int* ptr = (int*)::operator new(4);
new (ptr) int(5);
::operator delete(ptr, 4);
```