# 为面试准备的C++知识页面——所谓八股

## 0，NULL，nullptr
* 在C中，NULL被定义为空指针，#define NULL  ((void*)0)
* 在C++中，NULL被定义为0，#define NULL 0，nullptr被定义为空指针

## void*指针类型
* void* 是一个指针，指向一块没有数据类型的内存
* 可以指向任何类型的地址，必须强制转换才能正常取值

## 位运算bitwise
* bitset: 一个长度为N的二进制序列，可以和string和integer相互转换
* bitset<8> bitset1(12);  // 将12保存为8位二进制的序列
* bitset<8> bitset2("10101"); // 将字符串"10101"保存为8位二进制的序列

## RAII
* 资源获取即初始化，在构造函数中申请分配资源，在析构函数中释放资源，通过局部对象的生存期控制资源的生命周期。
* 在构造函数中初始化。局部对象在函数栈中声明后，会自动调用构造函数进行初始化。函数栈结束后，局部变量自动析构销毁，无需人工。常用于锁、智能指针、计时器等。

## 内存对齐
* 内存对齐是按照成员声明顺序依次安排内存的。
* 内存对齐的规则：（1）第一个成员相对首地址的偏移量为0，后面每一个成员相对首地址的偏移量为成员大小的整数倍；（2）最后整个结构体的大小为最大数据成员大小的整数倍。
* 内存对齐的好处：可以提高代码在不同平台的可移植性和内存访问性能。
    * CPU访问内存是按照内存读取粒度一块一块访问的
    * 不是所有硬件平台都可以访问任意地址上的数据

## 静态联编和动态联编
* 什么是联编：通过函数调用找到特定的函数代码块执行。通俗来说就是根据函数名（和参数列表）执行对应的函数代码块
* 静态联编：在编译期间进行的联编。优点是效率更高。编译器对非虚函数使用静态联编。
* 动态联编：编译期无法确定要执行的函数，在程序运行时选择正确的函数。编译器对虚函数使用动态联编。


## 向上强制转换和向下强制转换
* 向上强制转换：将派生类引用或指针转换为基类引用或指针，不需要显式类型转换。
```
因此，指向基类的指针或引用可以引用派生类的对象。
DerivedClass derived;
BaseClass* base_ptr = &derived;
BaseClass& base_ref = derived;
因此，在函数形参为基类的指针或引用时，实参可以为基类对象、派生类对象
```

* 向下强制转换：将基类引用或指针转换为派生类引用或指针，需要显式类型转换。
```
BaseClass base;
DerivedClass *derived = (DerivedClass*)&base;
```

## 虚函数的工作原理
* 虚函数：是实现C++三大特性之一（多态性）的方法。
* 虚函数表（V-table）：一片连续的内存，实际上是一个函数地址的数组。
* 如何实现：（1）在声明一个包含虚函数的类对象时，该对象中加了一个隐式成员，该成员为虚表指针，指向虚函数表。（2）调用虚函数时，程序将访问虚表指针，找到对应的虚函数表，然后根据使用的是第几个虚函数，调用虚函数表中对应顺序的函数。

## 虚函数的注意事项
* 构造函数不能是虚函数。
* 析构函数应为虚函数，除非不会作为基类。
* 友元函数不能是虚函数。因为友元函数不是类的成员，只有成员函数才能是虚函数。
* 派生类中没有重新定义：使用基类版本或者派生链中最新版本。
* 重新定义将隐藏：在派生类中重新定义虚函数，将隐藏基类中所有同名函数。
    * 返回类型协变：如果重新定义继承来的方法，应保持函数原型完全相同。但是如果返回类型是基类的引用或指针，则可以修改为派生类的引用或指针，允许返回类型根据类类型的变化而变化。
    * 如果基类中声明的虚函数被重载了，则应在派生类中重新定义所有重载的版本，否则会将其他版本隐藏。  

## 纯虚函数
* 在基类中没有具体实现的函数体的虚函数，被称为纯虚函数，又称为接口
* 纯虚函数要求派生类必须对该函数提供具体实现，所有纯虚函数都有具体实现，类才能被实例

## 左值和右值
* 左值：表达式结束后依然存在的持久对象，可以取地址，具名的变量或对象。
    * 前置自增自减表达式（--a, ++b）
    * 字符串字面值（"abc"）
    * 返回值为左值引用的函数调用
    * 有赋值运算符组成的表达式（a = b, b += 1）
* 右值：表达式结束后不再存在的临时对象，不可取地址，没有名字。
    * 除了字符串字面值的其他字面值（1, 'a', ture）
    * 后置自增自减表达式（a--, b++）
    * 返回值为非引用的函数调用或操作符重载
    * 算术、逻辑、比较、取地址、lambda表达式
* 将亡值：可以被移动的具名临时值。
    * 返回右值引用T&&的函数返回值
    * std::move()的返回值
    * 转换为T&&的类型转换函数的返回值

## 右值引用
* 左值引用：传统的C++引用，给左值取别名。非常量左值引用不能绑定右值。
* 右值引用(C++11): 给右值取别名。右值引用不能绑定左值。右值引用是左值。
```
int a = 10;
int &l = a;   // a是左值
int &&r = 10; // 10是右值
```

## std::move
* 作用：移除左值属性，将一个左值变成一个右值引用（将亡值），实现移动语义
* 移动语义：将对象的状态或所有权从一个对象转移到另一个对象，没有拷贝。

## 引用折叠
* 规则：
    * T& & -> T&
    * T&& & -> T&
    * T& && -> T&
    * T&& && -> T&&

## 模版推导
* 按值传递的模版推导：本质是对实参进行拷贝，得到实参的一个副本。因此，实参的常量性和引用性被忽略。
```
template<typename T>
returnType Function(T param) {
    Function2(param);
}
```
* 按引用传递的模版推导：忽略实参的引用性
```
template<typename T>
returnType Function(T& param) {
    Function2(param);
}
```
* 万能引用

## 万能引用
* 万能引用：函数既能接受左值类型的参数，也能接受右值类型的参数。
```
template<typename T>
returnType Function(T&& param) {
    Function2(param); // 函数内部对形参的直接使用，都是按照左值进行的。因此param是个左值类型
}
T是左值类型，T&&就是左值类型；T是右值类型，T&&就是右值类型
```

## std::forward
* 实现完美转发：std::forward会将输入的参数“原封不动”地传递到下一个函数中去。左值还是左值，右值还是右值。
* 步骤：（1）在模版中使用&&接受参数；（2）使用std::forward将参数转发给被调用的函数。
```
template<typename T>
returnType Function1(T&& param) {      // 万能引用：param既可以是左值类型，也可以是右值类型
    Function2(std::forward<T>(param)); // 完美转发：std::forward将param“原封不动“转发给Function2
}
```

## placement new
* 常规new一个对象，会先分配一个对应的内存空间，然后调用对象的构造函数构造一个对象。
* placement new：在new后面提供一个参数，作为new的地址，new会在给定的内存地址处构造对象。
```
int i = new int(10); // 常规new对象

new (&i) int(5); // placement new
```

## operator new/delete
* (T*)::operator new(size): 开辟一个大小为size的内存空间，地址的初始类型为void*，需强制转换为T*才可使用
* ::operator delete(ptr, size): 释放一个以ptr为首地址大小为size的内存空间
* 我的理解：所以new就是operator new + placement new?
```
int* ptr = (int*)::operator new(4);
new (ptr) int(5);
::operator delete(ptr, 4);
```

## trivial destructor
* trivial destructor: 用户没有自定义析构函数，使用系统自动生成的。
* non-trivial destructor: 用户自定义了析构函数。如果申请了内存空间，一定要显式释放。

## ++i和i++
```
// ++i的实现，返回一个引用
int& operator++() {
    *this += 1;
    return *this;
}

// i++的实现，返回一个对象
int opertator++(int) {
    int temp = *this;   // 产生一个临时对象temp，效率变低
    ++(*this);
    return temp;
}
```

## 指针和引用的区别
* 指针是一个变量，存储的是一个地址；引用只是原变量的别名
* 指针可以有多级，引用只能有一级
* 指针的声明和定义可以分开，引用在声明时必须初始化
* 指针可以重新指向其他变量，引用初始化后不可改变
* 指针作为参数传递时，实质上也是值传递，将实参（地址）的一个拷贝传递给形参，因此实参（地址）不会改变，实参指向的内容可以改变

## 传递函数参数时，指针和引用的区别
* 指针传递：本质还是值传递，传递的是地址。函数对形参的任何操作都是作为局部变量进行的，不会影响实参变量的值
* 引用传递：传递的是实参的引用。函数对形参的任何操作都会影响实参变量的值

## new/delete和malloc/free的异同
* 相同点：都是用于动态分配和释放内存
* 不同点
    1. 前者是C++运算符，后者是C++标准库函数
    2. new会自动计算分配内存的大小，malloc需要手动计算
    3. new是类型安全的，malloc不是
    4. new = ::operator new(size) + 构造函数，delete = 析构函数 + ::operator delete(ptr, size)；malloc和free不会调用相关函数
    5. new封装了malloc，直接free只是释放了内存，没有析构对象
    6. 前者返回具体类型指针，后者返回void类型指针

# 宏定义和typedef
* #define：在预处理阶段完成替换，之后被替换的文本参与编译，属于文本插入替换
* typedef：在编译期为类型取别名

# 变量的声明和定义
* 声明：将变量声明的位置和类型提供给编译器，并不分配内存空间
* 定义：为变量分配内存空间

## class和struct
* class默认private，struct默认public

## static
* 在类或结构体外使用static
    * 隐藏，变量或方法只在该cpp文件的翻译单元中可见
* 在类或结构体内使用static
    * 类或结构体中，静态属性是所有类实例共享的
        * 静态成员变量：所有类对象共享，需要在类定义外部定义
        * 静态成员函数：不具有this指针，不能访问非静态成员变量和调用非静态成员函数
        * 静态成员变量和函数可以被非静态成员函数任意访问
* 在局部作用域内使用static
    * 生存期和作用域：静态局部变量的生存期延长为整个程序的生存期，但是作用域仍是局部

## const
* const常量在声明时必须初始化
* 顶层和底层const
    * 顶层const: cosnt在*的右边
    * 底层const: const在*的左边
* 常量指针：指向常量的指针，指针可以改变，指向变量为常量 const int* p;
* 指针常量：指针是个常量，必须初始化，初始化后不能改变，int* const p;
* const在类中的使用
    * const成员变量：只能通过构造函数的初始化列表进行初始化
    * const对象不可以调用非const成员函数
    * const成员函数：this指针指向const对象，因此函数内不能修改对象
    
## 直接初始化和拷贝初始化
* 直接初始化：调用与实参匹配的构造函数
* 拷贝初始化：调用拷贝构造函数

## extern "C"
* 告诉编译器按照C语言进行编译，而不是C++

## 野指针和悬空指针
* 产生原因
    * 野指针：没有初始化的指针
    * 悬空指针：指向的内存被释放掉的指针
* 解决办法
    * 野指针：定义指针时及时初始化，或置空
    * 悬空指针：释放之后及时置空

## C和C++类型安全
* 类型安全：代码不会访问自己没有被授权的内存区域，很大程度上等价于内存安全
* C中的类型安全：C只在局部上下文中表现出类型安全
* C++中的类型安全：C++相比于C更具有类型安全性
    * new操作符返回的指针类型为具体对象指针，而不是void*
    * const关键字，dynamic_cast关键字设计类型检查
    * 模版支持类型检查

## 浅拷贝和深拷贝
* 浅拷贝：没有开辟新的地址，拷贝了一个指针，和原来的指针指向同一个地址
* 深拷贝：开辟了一块新的地址，来存放拷贝的值。在自己实现拷贝赋值时，对于指针变量需要自己实现深拷贝

## 内联函数
* 内联函数在编译时直接将函数代码插入目标代码中，省去函数调用的开销
* 内联函数并进行参数类型检查，具有返回值，可以实现重载
* 作为类成员接口函数来读写类的private或者protected成员，提高效率
* 不宜使用内联函数
    * 函数体代码较长
    * 函数题内有循环，执行时间比函数调用开销更大

## public，protected和private
* 访问权限
    * public：类的内外部都可以访问
    * protected：类的内部和派生类可以反问
    * private：类的内部可以访问
* 继承权限
    * public：基类中public和protected成员在派生类中保持原来的访问权限，private成员仍为private，不被派生类的子类访问
    * protected：基类中public和protected成员为派生类的protected成员，private成员仍为private
    * private：基类中public和protected成员为派生类的private成员，private成员仍为private，不被派生类的子类访问

## 大小端存储
* 大端存储：字数据的高字节存储在低地址中
* 小端存储：字数据的高字节存储在高地址中

## volatile, mutable, explicit关键字
* volatile：表示变量可以被某些编译器未知的因素更改，系统总是从所在的内存读取数据，多线程中被几个任务共享的变量需要定义为volatile类型
* mutable：可以更改的变量
* explicit：修饰类的构造函数，只能用在类内部的构造函数声明上，该类只能显式类型转换，禁止隐式转换
    * 隐式转换：C++允许编译器对代码执行一次隐式转换

## C++中的几种new的方式
* plain new: int* p = new int(1);              // 分配失败抛出异常std::bad_alloc
* nothrow new: int* p = new(nothrow) int(1);   // 分配失败不抛出异常，返回NULL
* placement new: int* q = new(p) int(2);       // 不分配内存，在给定内存上调用构造函数

## C++的异常处理
* try，throw，catch关键字：先执行try内的代码，如果没有异常则不会进入catch代码，如果有异常使用throw抛出异常，由catch根据throw的数据类型进行精准捕获
* 函数的异常声明列表：在函数的声明和定义时，指出可能抛出异常的列表
    * void func() throw(int, double, A, B ,C) {...}
* C++标准异常类
    * bad_alloc：new操作符内存动态分配失败
    * out_of_range：at()成员函数根据下标访问元素越界
    * bad_cast：dynamic_cast的强制类型转换不安全

## 初始化列表
* 赋值初始化：在构造函数体内初始化，所有数据成员都分配好内存后对各个成员进行初始化
* 列表初始化：在给数据成员分配内存时进行初始化，没有赋值操作，减少临时对象
    * 初始化列表按照成员定义顺序进行初始化

## 面向对象的三大特性
* 继承：在保持原有类特性的基础上进行扩展
* 多态：允许将子类类型的指针赋值给父类类型的指针，通俗来说，子类即可以是自身类型也可以是父类类型
* 封装：把数据和方法封装成一个抽象的类，外部只能访问类公开(public)的数据和方法

## 强制类型转换
* reinterpret_cast：将指针指向的内存空间重新解释为其他类型
* const_cast：用于去除或添加const属性的转换
* static_cast：没有运行时类型检查，用于简单类型之间的转换
* dynamic_cast：有运行时类型检查，转换不成功返回nullptr，主要用于类层次之前的向上和向下转换
    * 向上转换，dynamic_cast和static_cast效果相同
    * 向下转换，dinamix_cast具有类型检查，更安全

## 函数调用
1. 从栈空间分配存储空间
2. 从实参的存储空间复制值到形参的栈空间
3. 函数运算
* 形参在函数调用之前没有分配空间，函数调用结束后释放分配的空间

## 静态类型，动态类型，静态绑定，动态绑定
* 静态类型：对象在声明时采用的类型，编译器确定
* 动态类型：指针或引用目前所指对象的类型，运行时决定
* 静态绑定：函数或属性依赖于对象的静态类型，编译器确定，非虚函数
* 动态绑定：函数或属性依赖于对象的动态类型，运行时决定，虚函数实现多态

## 全局变量和局部变量
* 生存期：全局变量的生存期跟随程序，局部变量的生存期只在局部范围
* 作用域：全局变量全局可见，局部变量局部可见
* 存储位置：全局变量存储在全局存储区，局部变量存储在堆栈

## 指针的加减
* 指针加减本质是指针指向地址的移动，移动的步长取决于指针类型的大小

## 函数指针
* 声明：returnType (*func)(paramType param), func就是一个函数指针，指向一个参数为paramType param，返回值类型为returnType的函数
* 函数和数据类似，也有地址。函数名称就是一个地址，指向函数的代码

## C++从代码到可执行文件
1. 预编译：处理代码中#开头的预处理指令
2. 编译：预编译之后的文件，经过一系列的分析和优化之后生成汇编代码文件
    * 静态编译：编译器在编译可执行文件时，动态链接库中需要部分提取链接到可执行文件中，运行时不需要依赖动态链接库
    * 动态编译：动态编译的可执行文件带有一个动态链接库，缩小文件体积，加快编译速度
3. 汇编：将汇编代码翻译生成机器码
4. 链接：将不同cpp文件生成的目标文件链接，行客可执行程序。
    * 静态链接：在生成可执行文件时，把所有需要的函数二进制代码包含到可执行文件中
        * 优点：程序不需要依赖库，可独立执行
        * 缺点：一个模块更新需要重新编译打包整个代码库，占用较大空间。
    * 动态链接：将动态库加载到内存中，程序运行到指定代码时，去共享执行动态库中对应的可执行代码
        * 优点：将符号重定位推迟到运行时，解决静态编译的缺点
        * 缺点：结构复杂，影响性能。

## 友元
* 友元函数：定义在类外的普通函数，可以访问私有成员，需要在类中使用friend关键字声明
* 友元类：友元类的所有成员函数都是另一个类的友元函数，都可以访问私有成员，需要在类中使用friend关键字声明
* 友元关系：单向的、不可传递的，不可继承的

## 锁
* 读写锁：只允许一个写，允许同时读
* 互斥锁：一次只能一个线程拥有互斥锁，其他线程只能等待
* 条件变量：当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。
    * 总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。
* 自旋锁：如果进县城无法取得锁，不会立刻放弃，而是一直循环尝试获取锁，知道获取为止。一般应用于加锁时间很短的场景。 
* 条件变量：