# 多进程开发

## 程序：包含一系列信息的文件，描述如何在运行时创建一个进程
* 二进制格式标识：描述可执行文件格式的元信息，内核利用此信息解释文件中其他信息
* 机器语言指令：对程序算法进行编码
* 程序入口地址：标识程序开始执行时的起始指令位置
* 数据：变量初始值和字面量值
* 符号表和重定位表：描述程序中函数和变量的位置和位置，可用于调试和运行时符号解析（动态链接）
* 共享库和动态链接信息：列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径

## 进程：正在运行的程序的实例，在操作系统中，进程是基本的分配单元和执行单元
* 进程是内核定义的抽象实体，并为该实体分配用于执行程序的各项系统资源。
* 进程由用户内存空间和一系列内核数据结构组成
    * 用户内存空间：程序代码，代码使用的变量
    * 内核数据结构：用于维护进程状态，包括标识号（IDs），虚拟内存表，文件描述符表，信号传递及处理的有关信息，进程资源的使用和限制，当前工作目录和其他信息

## 程序和进程
* 程序是文件，占用磁盘空间的大小，但是不占用系统内存和CPU
* 进程是运行时，占用系统内存和CPU
* 一个程序可以创建多个进程

## 单道程序、多道程序
* 单道程序：在计算机内存中只允许一个程序运行
* 多道程序：在计算机内存中同时运行多个程序，在管理程序控制下，相互穿插运行，共享计算机系统资源，提高CPU利用率
    * 一个CPU任意时刻只能运行一个进程，多个进程轮流使用
    * 时间片（量子，处理器片）：操作系统分配给每个正在运行的进程的一段CPU时间，由内核调度程序分配给每个进程

## 并行和并发
* 并行（parallel）：在同一时刻，多条指令在多个处理器上同时执行
* 并发（concurrency）：在同一时刻只能有一条指令执行，多个进程中的指令快速交替执行

## 进程控制快（Processing Control Block）：内核为每个进程分配一个PCB，维护进程相关的信息
* linux内核的PCB是task_struct结构体
    * 进程ID：每个进程有唯一id，pid_t
    * 进程状态：就绪、运行、挂起、停止等
    * 进程切换时需要保存和恢复的CPU寄存器
    * 描述虚拟地址空间的信息
    * 描述控制终端的信息
    * 当前工作目录
    * umask掩码
    * 文件描述符表
    * 和信号相关的信息
    * 用户id和组id
    * 会话和进程组
    * 进程可以使用的资源上限

## 进程状态，随着进程的执行和外界条件的变化而转换
* （新建态），就绪态，运行态，阻塞态，（终止态）
    * 新建态：进程被创建时的状态
    * 运行态：占有处理器正在运行
    * 就绪态：进程具备运行条件，等待系统分配处理器。在一个系统中处于就绪态的进程可能有多个，排成队列（就绪队列）
    * 阻塞态：等待（wait）或睡眠（sleep），进程不具备运行条件，正在等待某个事件完成
    * 终止态：进程完成任务到达正常结束点，或出现错误而异常终止，或被操作系统所终止。
        * 新建态 --> 就绪态 <--> 运行态 --> 阻塞态 --> 就绪态 --> 终止态
    * 查看进程命令：
    ```
        ps aux/ajx
    ```
    * 实时显示进程状态
    ```
        top
    ```
    * 杀死进程
    ```
        kill -9 PID
    ```
    * 父进程：任何进程（除了init进程）都是由另一个进程（父进程，PPID）创建
    * 进程组（PGID）：一个或多个进程的集合

## 进程创建
* 系统允许一个进程创建子进程，子进程还可以创建子进程，形成进程树结构
```
    pid_t fork();
    成功创建，子进程中返回0，父进程中返回子进程的ID
    失败：进程数达到系统上线(EAGAIN)，或者内存不足(ENOMEM)
```

* fork之后，子进程的虚拟地址空间是拷贝父进程的，除了内核区中的PID不同。
    * 父子进程对变量是不是共享的？
        - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。
        - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。

## 进程调试
* GDB多进程调试
* GDB默认跟踪父进程，可以设置调试父进程或者子进程：`set follow-fork-mode [parent | child]`
    * 设置调试模式：`set detach-on-fork [on | off]`
    * 查看调试进程：`info inferiors`
    * 切换调试进程：`inferior id`
    * 脱离GDB调试：`detach inferiors id`

* exec函数族：使用另一个可执行程序替换当前的进程。
* 在执行一个进程的过程中，通过exec函数使得另一个可执行程序A的数据段、代码段和堆栈段取代当前进程B的数据段、代码段和堆栈段，那么当前的进程就开始执行A中的内容，这一过程中不会创建新的进程，而且PID也没有改变。
```
    int execl(const char *path, const char *arg, .../* (char  *) NULL */);
    int execlp(const char *file, const char *arg, .../* (char  *) NULL */);
    ...
    l表示命令行参数列表、p表示PATH环境变量、v表示使用参数数组、e使用环境变量数组
```
* exec函数族错误原因：
    * 找不到文件或路径， errno=ENOENT
    * 没有可执行文件的运行权限，errno=EACCES
    * 数组argv和envp(环境变量数组)没有以NULL结尾，errno=EFAULT

* 孤儿进程：父进程结束，子进程还在运行。
    * 当出现一个孤儿进程时，内核将孤儿进程的父进程这是为init进程，负责回收资源

* 僵尸进程
    * 每个进程结束后，都会释放虚拟地址空间中的用户区数据，但是无法释放内核区PCB数据。
    * 内核区PCB数据需要父进程释放。当进程结束时，父进程还没有释放，子进程残留在内核区中，成为僵尸进程
    * 危害：僵尸进程占用进程号，系统所用的进程号有限

## 进程回收
* 进程回收：进程退出时，内核释放该进程所使用的资源（文件、内存等），但是保留一部分信息（主要是PCB信息，进程号、退出状态、运行时间等）
    * 父进程通过调用wait()或waitpid()得到退出状态，同时彻底清除掉进程。

* wait(int *wstatus)：等待任意一个子进程结束，如果任意一个子进程结束了，函数会回收子进程的资源
    * 调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）
    * 如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.
    * 成功：返回被回收的子进程的id
    ```
        int status;
        int ret = wait(&status);
        if (WIFEXITED(status)) {
            printf("退出的状态码：%d\n", WEXITSTATUS(st));   // 是不是正常退出
        }
        if(WIFSIGNALED(st)) {
            printf("被%d信号kill\n", WTERMSIG(st));   // 是不是异常终止
        }
    ```
* waitpid(pid_t pid, int *wstatus, int options)：回收指定进程号的子进程，可以设置是否阻塞
    - pid:
        + pid > 0 : 某个子进程的pid
        + pid = 0 : 回收当前进程组的所有子进程
        + pid = -1 : （最常用）回收所有的子进程，相当于wait()
        + pid < -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程
    - options: 设置阻塞或者非阻塞
        + 0：阻塞
        + WNOHANG：非阻塞
    - 返回值：
        + > 0 : 返回子进程的id
        + = 0 : options=WNOHANG, 表示还有子进程
        + = -1 ：错误，或者没有子进程了

## 进程间通信（IPC：Inter Processes Communication）
* 每个进程都是一个独立的资源分配单元，不同进程之间无法直接访问资源。但是不同进程之间需要进行信息交互和状态传递
* 目的
    - 数据传输、通知事件、资源共享（内核提供互斥和同步机制）、进程控制（一个进程对另一个进程的控制）
* 进程间的通信方式
    - 同一主机的进程间通信：
        + Unix进程间通信：匿名管道、有名管道、信号
        + System V进程间通信方式：消息队列、共享内存、信号量
    - 不同主机的进程间通信：Socket

* 管道：
    - 一个在内核内存中维护的缓冲器，存储能力有限，不同操作系统大小不一定相同
    - 拥有文件的特点：读写操作，匿名管道没有文件实体，有名管道有文件实体但是不存储数据。可以按照操作文件的方式对管道进行操作，数据都存储在内存中。
    - 管道是一个单向的字节流，没有消息的概念，一端写入一端读取（任意读取），半双工。
    - 管道传递的数据是顺序的，管道的数据结果是一个循环队列
    - 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞
    * 管道读写:
        - 读管道
            - 管道中有数据，read返回实际读到的字节数。
            - 管道中无数据：
                - 写端被全部关闭，read返回0（相当于读到文件的末尾）
                - 写端没有完全关闭，read阻塞等待

        - 写管道：
            - 管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）
            - 管道读端没有全部关闭：
                - 管道已满，write阻塞
                - 管道没有满，write将数据写入，并返回实际写入的字节数
```
    ls | wc -l
    ls命令是一个进程，wc命令是一个进程，｜是一个管道符，将ls进程的数据传输给wc进程
```

* 匿名管道：无名管道，UNIX最古老的进程间通信方式，所有UNIX系统都支持
    * 只能在具有公共祖先的进程之间使用（有关系的进程间通信）：共享文件描述符
    * int pipe(int pipefd[2])
        - 功能：创建一个匿名管道，用来进程间通信
        - 参数：传出参数，pipefd[0]是读取端，pipefd[1]是写入端
    * ulimit –a 查看管道缓冲大小的命令
```
    #include <unistd.h>

    int pipefd[2];
    int pipe(pipefd);

    // 获取管道的大小
    long size = fpathconf(pipefd[0], _PC_PIPE_BUF);
```

* 有名管道：（无关系的进程间通信）命名管道，以FIFO文件形式存在于文件系统中
    - FIFO文件是一个特殊的文件，内容存储在内存中
    - 使用FIFO的进程推出后，FIFO文件继续保存在内存中
    - 不相关的进程可以通过名字打开FIFO文件进行通信
```
    创建fifo文件
    1.通过命令： mkfifo 名字
    2.通过函数：int mkfifo(const char *pathname, mode_t mode);

    #include <sys/types.h>
    #include <sys/stat.h>
    int mkfifo(const char *pathname, mode_t mode);
        参数：
            - pathname: 管道名称的路径
            - mode: 文件的权限 和 open 的 mode 是一样的
                    是一个八进制的数
        返回值：成功返回0，失败返回-1，并设置错误号
```

- 有名管道的注意事项：
    1. 一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道
    2. 一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道

    - 读管道：
        - 管道中有数据，read返回实际读到的字节数
        - 管道中无数据：
            - 管道写端被全部关闭，read返回0，（相当于读到文件末尾）
            - 写端没有全部被关闭，read阻塞等待

    - 写管道：
        - 管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）
        - 管道读端没有全部关闭：
            - 管道已经满了，write会阻塞
            - 管道没有满，write将数据写入，并返回实际写入的字节数。