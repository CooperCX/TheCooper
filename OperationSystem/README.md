# 操作系统

## 程序：包含一系列信息的文件，描述如何在运行时创建一个进程
* 二进制格式标识：描述可执行文件格式的元信息，内核利用此信息解释文件中其他信息
* 机器语言指令：对程序算法进行编码
* 程序入口地址：标识程序开始执行时的起始指令位置
* 数据：变量初始值和字面量值
* 符号表和重定位表：描述程序中函数和变量的位置和位置，可用于调试和运行时符号解析（动态链接）
* 共享库和动态链接信息：列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径

## 进程：正在运行的程序的实例，在操作系统中，进程是基本的分配单元和执行单元
* 进程是内核定义的抽象实体，并为该实体分配用于执行程序的各项系统资源。
* 进程由用户内存空间和一系列内核数据结构组成
    * 用户内存空间：程序代码，代码使用的变量
    * 内核数据结构：用于维护进程状态，包括标识号（IDs），虚拟内存表，文件描述符表，信号传递及处理的有关信息，进程资源的使用和限制，当前工作目录和其他信息

## 程序和进程
* 程序是文件，占用磁盘空间的大小，但是不占用系统内存和CPU
* 进程是运行时，占用系统内存和CPU
* 一个程序可以创建多个进程

## 线程：是进程的一个实体，一个执行路径；是比进程更小的独立运行的基本单位，一个进程至少拥有一个线程
* 用户线程：不需要内核支持，在用户区中实现。用户进程利用线程库控制用户线程，不需要切换状态
    - 优点：简单、灵活、快
    - 缺点：同一个进程只能有一个线程在运行，同一个进程的线程只能在同一个处理机下分时复用
* 内核线程：有操作系统内核创建和销毁，内核维护进程和线程的上下文信息和线程切换。
    - 优点：有多个处理机时，一个进程的多线程可以同时运行。一个内核线程阻塞不会影响其他线程
    - 缺点：由内核调度
* 上下文：CPU当前的寄存器信息
* 上下文切换：保存、恢复CPU的寄存器信息
* 线程同步：多线程通过特定的设置来控制线程之间的执行顺序
    - 信号量（Semaphore）：允许多个线程在同⼀时刻访问同⼀资源，但是需要限制在同⼀时刻访问此资源的最⼤线程数⽬
    - 互斥对象（Mutex）：采⽤互斥对象机制，互斥对象只有一个，只有拥有互斥对象的线程才有访问公共资源的权限。
        - Mutex的本质是上限为1的Semaphore
    - 临界区：在任意⼀个时刻只允许⼀个线程进入临界区，对共享资源进⾏访问
        - 临界区是Mutex加锁解锁中间的代码
    - 原子操作Atomic：效率更高，但是不是所有编译器CPU都支持
    - 事件对象：通过通知操作的⽅式来保持线程的同步，还可以⽅便实现对多个线程的优先级 ⽐较的操作
* 线程安全：线程安全问题都是全局变量和静态变量引起的。如果有多个线程同时执行写操作，就需要考虑。
    - 加锁：实现线程执⾏的串⾏化，从⽽保证多线程同时操作对象的安全性，⼀个是语法层⾯的互斥锁，⼀个是API层⾯的互斥锁.​
    - 线程本地化：利⽤Threadlocal来为每⼀个线程创造⼀个共享变量的副本

## thread_local
* 独属于某个线程的静态变量

## 进程和线程
* 线程在程序中独立、并发的执行流
* 线程具有更高的性能：多个线程共享同一个进程的虚拟空间
* 创建进程时，系统必须分配独立的内存空间

## 虚拟内存
* 虚拟内存的大小有CPU的位数（CPU寻址多少位）决定，32位CPU的虚拟内存空间位4GB（2 ^ 32），64位CPU的虚拟内存空间位16GGB（2 ^ 64）
* 虚拟内存到物理内存的映射需要MMU和操作系统合作，依靠硬件提供支持
* 好处
    1. 程序加载提供灵活性
    2. 隔离进程
    3. 有效利用内存资源
    4. swap功能：物理内存用尽，通过将内存和硬盘互相转移，利用硬盘资源扩展内存空间

## 内存管理单元MMU: 映射到真实物理内存
* 进程空间；空间独立性，依靠MMU实现。没有MMU，没办法实现内存空间的隔离，没办法实现进程要求的空间独立性，进程也就不存在了，只有线程。
* 多线程：多个线程共享一个进程空间，可以实现线程间通信。一旦任何一个线程破溃，其他全部崩溃。

## 内存分页：内存映射表（页表）中每一行（4个字节）映射到一段4K字节的连续内存
* 在32位系统中，虚拟地址的高20位表示在页表中的外部索引位置，低12位表示在内存页中的内部索引位置
* 每个进程都有自己的页表，如果页表不同则是隔离的，如果相同或部分相同则是进程间内存共享
* 线程没有自己的页表，共享进程的页表，是内存共享的

## 协程：一种函数对象，可以设置锚点实现暂停执行或恢复运行，一个线程可以拥有多个协程
* 每个协程表示一个执行单元，有自己的本地数据，和其他协程共享全局数据和其他资源
* 和线程相比，执行效率高，开销小，不需要锁（因为协程是可中断恢复的函数，可以实现同步+并发）

## 用户态和内核态
* 用户态：当进程运行在用户空间时，当程序运行的特权级在3级。
    - 不能直接访问操作系统内核数据结构和程序。当执行系统调用时，需要系统中断切换到内核态执行。
* 内核态：当进程运行在内核空间时，当程序运行的特权级在0级。

## CPU中断（系统中断）
* 计算机在执行程序期间，收到了中断信息，暂停正在执行的程序转而去执行相应的事件处理程序，处理完毕后继续执行原来程序，是多程序并发执行的前提。
* CPU在执行程序时可接受外部设备或内部信号，来及时响应事件或故障
* 中断发生时，操作系统的管理需要特权，CPU进入内核态。用户态切换到内核态只能通过中断机制实现
* 处理流程
    1. CPU 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；
    2. CPU 根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序；
    3. CPU 恢复寄存器中的数值，返回原程序流停止位置继续执行。
* 两种中断
    - 内（软）中断：软件中断、同步中断，来源于CPU内部，与当前执行的指令有关
    - 外（硬）中断：硬件中断、异步中断，来源于CPU外部，与当前执行的指令无关
        + 外部设备想中断控制器发送中断请求，中断控制器根据优先级，将中断请求发送给CPU

* 中断描述符表（IDT）：记录中断处理函数的地址和其他控制位，最多支持256个中断向量，中断号0-31为系统预留
    * 中断向量（门描述符）：中断发生时必须通过门才能进入对应处理程序
        - 中断门：进入中断处理程序后，去除IF标志，关闭中断
        - 陷阱门：进入中断处理程序后，保留IF标志，不关闭中断
        - 任务门：段选择符中时任务状态段的选择子，可以和硬件配合制定运行的任务

## 单道程序、多道程序
* 单道程序：在计算机内存中只允许一个程序运行
* 多道程序：在计算机内存中同时运行多个程序，在管理程序控制下，相互穿插运行，共享计算机系统资源，提高CPU利用率
    * 一个CPU任意时刻只能运行一个进程，多个进程轮流使用
    * 时间片（量子，处理器片）：操作系统分配给每个正在运行的进程的一段CPU时间，由内核调度程序分配给每个进程

## 并行和并发
* 并行（parallel）：在同一时刻，多条指令在多个处理器上同时执行
* 并发（concurrency）：在同一时刻只能有一条指令执行，多个进程中的指令快速交替执行

## 常见的IO模型


## 进程控制快（Processing Control Block）：内核为每个进程分配一个PCB，维护进程相关的信息
* linux内核的PCB是task_struct结构体
    * 进程ID：每个进程有唯一id，pid_t
    * 进程状态：就绪、运行、挂起、停止等
    * 进程切换时需要保存和恢复的CPU寄存器
    * 描述虚拟地址空间的信息
    * 描述控制终端的信息
    * 当前工作目录
    * umask掩码
    * 文件描述符表
    * 和信号相关的信息
    * 用户id和组id
    * 会话和进程组
    * 进程可以使用的资源上限

## 进程状态，随着进程的执行和外界条件的变化而转换
* （新建态），就绪态，运行态，阻塞态，（终止态）
    * 新建态：进程被创建时的状态
    * 运行态：占有处理器正在运行
    * 就绪态：进程具备运行条件，等待系统分配处理器。在一个系统中处于就绪态的进程可能有多个，排成队列（就绪队列）
    * 阻塞态：等待（wait）或睡眠（sleep），进程不具备运行条件，正在等待某个事件完成
    * 终止态：进程完成任务到达正常结束点，或出现错误而异常终止，或被操作系统所终止。
        * 新建态 --> 就绪态 <--> 运行态 --> 阻塞态 --> 就绪态 --> 终止态
    * 查看进程命令：
    ```
        ps aux/ajx
    ```
    * 实时显示进程状态
    ```
        top
    ```
    * 杀死进程
    ```
        kill -9 PID
    ```
    * 父进程：任何进程（除了init进程）都是由另一个进程（父进程，PPID）创建
    * 进程组（PGID）：一个或多个进程的集合

## 进程创建
* 系统允许一个进程创建子进程，子进程还可以创建子进程，形成进程树结构
```
    pid_t fork();
    成功创建，子进程中返回0，父进程中返回子进程的ID
    失败：进程数达到系统上线(EAGAIN)，或者内存不足(ENOMEM)
```

* fork之后，子进程的虚拟地址空间是拷贝父进程的，除了内核区中的PID不同。
    * 父子进程对变量是不是共享的？
        - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。
        - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。

## 进程调试
* GDB多进程调试
* GDB默认跟踪父进程，可以设置调试父进程或者子进程：`set follow-fork-mode [parent | child]`
    * 设置调试模式：`set detach-on-fork [on | off]`
    * 查看调试进程：`info inferiors`
    * 切换调试进程：`inferior id`
    * 脱离GDB调试：`detach inferiors id`

* exec函数族：使用另一个可执行程序替换当前的进程。
* 在执行一个进程的过程中，通过exec函数使得另一个可执行程序A的数据段、代码段和堆栈段取代当前进程B的数据段、代码段和堆栈段，那么当前的进程就开始执行A中的内容，这一过程中不会创建新的进程，而且PID也没有改变。
```
    int execl(const char *path, const char *arg, .../* (char  *) NULL */);
    int execlp(const char *file, const char *arg, .../* (char  *) NULL */);
    ...
    l表示命令行参数列表、p表示PATH环境变量、v表示使用参数数组、e使用环境变量数组
```
* exec函数族错误原因：
    * 找不到文件或路径， errno=ENOENT
    * 没有可执行文件的运行权限，errno=EACCES
    * 数组argv和envp(环境变量数组)没有以NULL结尾，errno=EFAULT

* 孤儿进程：父进程结束，子进程还在运行。
    * 当出现一个孤儿进程时，内核将孤儿进程的父进程这是为init进程，负责回收资源

* 僵尸进程
    * 每个进程结束后，都会释放虚拟地址空间中的用户区数据，但是无法释放内核区PCB数据。
    * 内核区PCB数据需要父进程释放。当进程结束时，父进程还没有释放，子进程残留在内核区中，成为僵尸进程
    * 危害：僵尸进程占用进程号，系统所用的进程号有限

* 守护进程
    * 在后台运行，独立于终端（避免在终端显示和受到终端中断），周期性执行某种任务

## 进程回收
* 进程回收：进程退出时，内核释放该进程所使用的资源（文件、内存等），但是保留一部分信息（主要是PCB信息，进程号、退出状态、运行时间等）
    * 父进程通过调用wait()或waitpid()得到退出状态，同时彻底清除掉进程。

* wait(int *wstatus)：等待任意一个子进程结束，如果任意一个子进程结束了，函数会回收子进程的资源
    * 调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）
    * 如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.
    * 成功：返回被回收的子进程的id
    ```
        int status;
        int ret = wait(&status);
        if (WIFEXITED(status)) {
            printf("退出的状态码：%d\n", WEXITSTATUS(st));   // 是不是正常退出
        }
        if(WIFSIGNALED(st)) {
            printf("被%d信号kill\n", WTERMSIG(st));   // 是不是异常终止
        }
    ```
* waitpid(pid_t pid, int *wstatus, int options)：回收指定进程号的子进程，可以设置是否阻塞
    - pid:
        + pid > 0 : 某个子进程的pid
        + pid = 0 : 回收当前进程组的所有子进程
        + pid = -1 : （最常用）回收所有的子进程，相当于wait()
        + pid < -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程
    - options: 设置阻塞或者非阻塞
        + 0：阻塞
        + WNOHANG：非阻塞
    - 返回值：
        + > 0 : 返回子进程的id
        + = 0 : options=WNOHANG, 表示还有子进程
        + = -1 ：错误，或者没有子进程了

## 进程间通信（IPC：Inter Processes Communication）
* 每个进程都是一个独立的资源分配单元，不同进程之间无法直接访问资源。但是不同进程之间需要进行信息交互和状态传递
* 目的
    - 数据传输、通知事件、资源共享（内核提供互斥和同步机制）、进程控制（一个进程对另一个进程的控制）
* 进程间的通信方式
    - 同一主机的进程间通信：
        + Unix进程间通信：匿名管道、有名管道、信号
        + System V进程间通信方式：消息队列、共享内存、信号量
    - 不同主机的进程间通信：Socket

* 管道：
    - 一个在内核内存中维护的缓冲器，存储能力有限，不同操作系统大小不一定相同
    - 拥有文件的特点：读写操作，匿名管道没有文件实体，有名管道有文件实体但是不存储数据。可以按照操作文件的方式对管道进行操作，数据都存储在内存中。
    - 管道是一个单向的字节流，没有消息的概念，一端写入一端读取（任意读取），半双工。
    - 管道传递的数据是顺序的，管道的数据结果是一个循环队列
    - 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞
    * 管道读写:
        - 读管道
            - 管道中有数据，read返回实际读到的字节数。
            - 管道中无数据：
                - 写端被全部关闭，read返回0（相当于读到文件的末尾）
                - 写端没有完全关闭，read阻塞等待

        - 写管道：
            - 管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）
            - 管道读端没有全部关闭：
                - 管道已满，write阻塞
                - 管道没有满，write将数据写入，并返回实际写入的字节数
```
    ls | wc -l
    ls命令是一个进程，wc命令是一个进程，｜是一个管道符，将ls进程的数据传输给wc进程
```

* 匿名管道：无名管道，UNIX最古老的进程间通信方式，所有UNIX系统都支持
    * 只能在具有公共祖先的进程之间使用（有关系的进程间通信）：共享文件描述符
    * int pipe(int pipefd[2])
        - 功能：创建一个匿名管道，用来进程间通信
        - 参数：传出参数，pipefd[0]是读取端，pipefd[1]是写入端
    * ulimit –a 查看管道缓冲大小的命令
```
    #include <unistd.h>

    int pipefd[2];
    int pipe(pipefd);

    // 获取管道的大小
    long size = fpathconf(pipefd[0], _PC_PIPE_BUF);
```

* 有名管道：（无关系的进程间通信）命名管道，以FIFO文件形式存在于文件系统中
    - FIFO文件是一个特殊的文件，内容存储在内存中
    - 使用FIFO的进程推出后，FIFO文件继续保存在内存中
    - 不相关的进程可以通过名字打开FIFO文件进行通信
```
    创建fifo文件
    1.通过命令： mkfifo 名字
    2.通过函数：int mkfifo(const char *pathname, mode_t mode);

    #include <sys/types.h>
    #include <sys/stat.h>
    int mkfifo(const char *pathname, mode_t mode);
        参数：
            - pathname: 管道名称的路径
            - mode: 文件的权限 和 open 的 mode 是一样的
                    是一个八进制的数
        返回值：成功返回0，失败返回-1，并设置错误号
```

- 有名管道的注意事项：
    1. 一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道
    2. 一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道

    - 读管道：
        - 管道中有数据，read返回实际读到的字节数
        - 管道中无数据：
            - 管道写端被全部关闭，read返回0，（相当于读到文件末尾）
            - 写端没有全部被关闭，read阻塞等待

    - 写管道：
        - 管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）
        - 管道读端没有全部关闭：
            - 管道已经满了，write会阻塞
            - 管道没有满，write将数据写入，并返回实际写入的字节数。

- 消息队列：消息连接表，存放在内核中，⼀个消息队列由⼀个标识符来标识；
    - 消息队列独⽴于发送与接收进程。进程终⽌时，消息队列及其内容并不会被删除；

- 信号量：信号量是⼀个计数器，信号量⽤于实现进程间的互斥与同步，⽽不是⽤于存储进程间通信数据；
    - 信号量⽤于进程间同步，若要在进程间传递数据需要结合共享内存；

- 共享内存：两个或多个进程共享⼀个给定的存储区；
    - 共享内存是最快的⼀种进程通信⽅式，因为进程是直接对内存进⾏存取；
    - 因为多个进程可以同时操作，所以需要使用信号量进⾏同步；
